# 3.1.4.1. Padrão GOF: Facade

## 1. Introdução

O padrão de projeto Facade pertence ao grupo dos padrões estruturais e tem como objetivo principal fornecer uma interface simplificada para um conjunto de subsistemas ou classes complexas.  
Sua aplicação promove o encapsulamento da lógica de negócio, facilitando o uso dos serviços do backend e reduzindo o acoplamento entre módulos (GAMMA et al., 1995).

No projeto "O que planejo fazer", o Facade foi utilizado para centralizar as operações de tarefas e categorias em serviços dedicados (`TarefaService` e `CategoriaService`).  
Esses serviços encapsulam toda a lógica de negócio, validações e acesso ao banco de dados, tornando os controllers mais enxutos e o sistema mais organizado e fácil de manter.

---

## 2. Metodologia

A implementação do padrão Facade seguiu as seguintes etapas metodológicas:

1. **Análise das operações:**  
   Foram identificadas as operações de criação, edição, remoção e listagem de tarefas e categorias como candidatas para centralização em serviços.

2. **Modelagem da solução:**  
   Foram criados serviços (`Service`) para cada entidade, encapsulando regras de negócio, validações e chamadas ao banco de dados.

3. **Implementação:**  
   Os services foram implementados como módulos independentes, sendo consumidos pelos controllers, que passaram a delegar toda a lógica para o Facade.

4. **Validação e Testes:**  
   Testes foram realizados com o *Insomnia* para garantir que as operações funcionassem corretamente e que os controllers estivessem desacoplados da lógica de negócio.

---

## 3. Participação, Colaboração e Senso Crítico

| Matrícula | Aluno |
|------------|--------|
| 19/0085045 | Brenno Oliveira |
| 20/0024787 | Mateus Siqueira |

O desenvolvimento e aplicação do padrão GoFs Estrutural Facade foi realizado pela dupla Brenno Oliveira e Mateus Siqueira, com reuniões via *Google Meet* e revisões conjuntas de código.

Durante o processo, foi realizado uma análise da estrutura do sistema e identificou pontos em que o uso do Facade poderia simplificar a interação entre subsistemas complexos. Onde permite reduzir o acoplamento e melhorar a legibilidade e a manutenibilidade do código. Aplicando a arquiteura dentro da [US07 - Criar listas/categorias](https://unbarqdsw2025-2-turma02.github.io/2025.2_T02_G1_OquePlanejoFazer_Entrega_02/#/Modelagem/2.5.2.DeclaracaoRequisitos).

Além disso, a implementação do Facade reforçou o entendimento dos conceitos de abstração e encapsulamento, e demonstrou na prática como os padrões GoF podem ser aplicados para otimizar a arquitetura de software e facilitar futuras extensões do sistema.  

O desenvolvimento em dupla foi importatnte para discutir alternativas de implementação, revisar decisões técnicas e garantir que a utilização do padrão fora feito de modo correto.

---

## 4. Justificativa da Decisão Arquitetural

A escolha pelo uso do padrão Facade foi motivada pelos seguintes fatores:

- **Centralização da lógica de negócio:** facilita manutenção e evolução do sistema.
- **Redução do acoplamento:** controllers ficam mais simples e desacoplados das regras de negócio.
- **Facilidade de testes:** services podem ser testados isoladamente.
- **Escalabilidade:** permite adicionar novas funcionalidades sem impactar os controllers.
- **Organização e clareza:** melhora a estrutura do código e a compreensão do fluxo de dados.

---

## 5. Informações Técnicas e Implementação

### 5.1 Tecnologias Utilizadas

- JavaScript  
- Node.js  
- Mongoose (para persistência no MongoDB)  
- Insomnia/Postman (para testes e validação)  

---

### 5.2 Estrutura da Implementação

#### 5.2.1 Service de Categoria (Facade)

Centraliza toda a lógica de negócio e acesso ao banco para categorias.

```javascript
import Categoria from '../models/Categoria.js';
import CategoriaFactory from '../controllers/factories/CategoriaFactory.js';
import CategoriaIterator from '../controllers/iterators/CategoriaIterator.js';
import CategoriaRepository from '../repository/CategoriaRepository.js';

class CategoriaService {
  async criarCategoria(nome, cor) {
    CategoriaFactory.criarCategoria(nome, cor);
    const categoria = new Categoria({ nome, cor });
    await categoria.save();
    return categoria;
  }

  async listarCategorias() {
    return await Categoria.find().sort({ criadoEm: -1 });
  }

  async listarCategoriasPaginadas(page = 1, limit = 5) {
    const skip = (page - 1) * limit;
    const categorias = await Categoria.find()
      .sort({ criadoEm: -1 })
      .skip(skip)
      .limit(limit);
    const total = await Categoria.countDocuments();
    return {
      categorias,
      pagination: {
        totalItems: total,
        totalPages: Math.ceil(total / limit),
        currentPage: page,
        hasNext: (page * limit) < total,
      }
    };
  }

  async editarCategoria(id, nome) {
    const categoria = await Categoria.findById(id);
    if (!categoria) throw new Error('Categoria não encontrada');
    if (nome) categoria.nome = nome;
    await categoria.save();
    return categoria;
  }

  async removerCategoria(id) {
    const categoria = await Categoria.findByIdAndDelete(id);
    if (!categoria) throw new Error('Categoria não encontrada');
    return categoria;
  }
}

export default new CategoriaService();

```

### 5.2.2 Service de Tarefa (Facade)

Centraliza toda a lógica de negócio e acesso ao banco para tarefas.

```javascript

    // Facade para lógica de negócio de tarefas
import TarefaRepository from '../repository/TarefaRepository.js';
import TarefaFactory from '../controllers/factories/TarefaFactory.js';
import TarefaIterator from '../controllers/iterators/TarefaIterator.js';

class TarefaService {
  constructor() {
    this.repository = new TarefaRepository();
  }

  async criarTarefa(dados) {
    const { tipo, ...dadosDaTarefa } = dados;
    const ModeloCorreto = TarefaFactory.getModel(tipo);
    const novaTarefa = new ModeloCorreto(dadosDaTarefa);
    return this.repository.create(novaTarefa);
  }

  async listarTarefas(filtro, page, limit) {
    const iterator = new TarefaIterator(filtro, page, limit);
    const tarefas = await iterator.getCurrentPage();
    const paginationInfo = iterator.getPaginationInfo();
    return { tarefas, pagination: paginationInfo };
  }

  async buscarTarefaPorId(id) {
    return this.repository.findById(id);
  }

  async editarTarefa(id, dadosAtualizacao) {
    return this.repository.update(id, dadosAtualizacao);
  }

  async removerTarefa(id) {
    return this.repository.delete(id);
  }
}

export default TarefaService;
```

### 5.2.3 Utilização nos Controllers

Os controllers utilizam os services para delegar toda a lógica de negócio, tornando o código mais limpo e organizado.

Controller de Categoria:

```javascript

    import CategoriaService from '../services/CategoriaService.js';

class CategoriaController {
  async criarCategoria(req, res) {
    try {
      const { nome, cor } = req.body;
      if (!nome || !cor) {
        return res.status(400).json({ error: 'Nome e cor da categoria são obrigatórios' });
      }
      const categoria = await CategoriaService.criarCategoria(nome, cor);
      res.status(201).json({ message: 'Categoria criada com sucesso', categoria });
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }

  async listarCategorias(req, res) {
    try {
      const categorias = await CategoriaService.listarCategorias();
      res.json({ message: 'Categorias listadas com sucesso', categorias });
    } catch (error) {
      res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }

  async listarCategoriasPaginadas(req, res) {
    try {
      const { page = 1, limit = 5 } = req.query;
      const result = await CategoriaService.listarCategoriasPaginadas(Number(page), Number(limit));
      res.json(result);
    } catch (error) {
      res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }

  async editarCategoria(req, res) {
    try {
      const { id } = req.params;
      const { nome } = req.body;
      const categoria = await CategoriaService.editarCategoria(id, nome);
      res.json({ message: 'Categoria editada com sucesso', categoria });
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }

  async removerCategoria(req, res) {
    try {
      const { id } = req.params;
      const categoria = await CategoriaService.removerCategoria(id);
      res.json({ message: 'Categoria removida com sucesso', categoria });
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }
}

export default CategoriaController;

```

Controller de Tarefa:

```Javascript
import TarefaService from '../services/TarefaService.js';

const service = new TarefaService();

class TarefaController {
  static async createTarefa(req, res) {
    try {
      const tarefa = await service.criarTarefa(req.body);
      res.status(201).json({ message: 'Tarefa criada com sucesso', tarefa });
    } catch (error) {
      console.error('Erro ao criar tarefa:', error);
      res.status(500).json({ error: 'Erro interno do servidor', details: error.message });
    }
  }

  static async listarTarefas(req, res) {
    try {
      const { tipo, concluida, prioridade, categoria, page, limit } = req.query;
      let filtro = {};
      if (tipo) filtro.tipo = tipo;
      if (concluida !== undefined) filtro.concluida = concluida === 'true';
      if (prioridade) filtro.prioridade = prioridade;
      if (categoria) filtro.categoria = categoria;
      const result = await service.listarTarefas(filtro, page, limit);
      res.json({ message: 'Tarefas listadas com sucesso', ...result });
    } catch (error) {
      console.error('Erro ao listar tarefas:', error);
      res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }

  static async buscarTarefaPorId(req, res) {
    try {
      const { id } = req.params;
      const tarefa = await service.buscarTarefaPorId(id);
      if (!tarefa) {
        return res.status(404).json({ error: 'Tarefa não encontrada' });
      }
      res.json({ message: 'Tarefa encontrada', tarefa });
    } catch (error) {
      console.error('Erro ao buscar tarefa:', error);
      res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }

  static async editarTarefa(req, res) {
    try {
      const { id } = req.params;
      const tarefa = await service.editarTarefa(id, req.body);
      if (!tarefa) {
        return res.status(404).json({ error: 'Tarefa não encontrada' });
      }
      res.json({ message: 'Tarefa editada com sucesso', tarefa });
    } catch (error) {
      console.error('Erro ao editar tarefa:', error);
      res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }

  static async concluirTarefa(req, res) {
    try {
      const { id } = req.params;
      const tarefa = await service.editarTarefa(id, { concluida: true });
      if (!tarefa) {
        return res.status(404).json({ error: 'Tarefa não encontrada' });
      }
      res.json({ message: 'Tarefa concluída com sucesso', tarefa });
    } catch (error) {
      console.error('Erro ao concluir tarefa:', error);
      res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }

  static async removerTarefa(req, res) {
    try {
      const { id } = req.params;
      const tarefaRemovida = await service.removerTarefa(id);
      if (!tarefaRemovida) {
        return res.status(404).json({ error: 'Tarefa não encontrada' });
      }
      res.json({ message: 'Tarefa removida com sucesso', tarefaRemovida });
    } catch (error) {
      console.error('Erro ao remover tarefa:', error);
      res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }
}

export default TarefaController; 

```

## 6. Como Executar a Implementação

### 6.1 Pré-requisitos

- Node.js instalado
- MongoDB rodando localmente ou em nuvem
- Executar `npm install` para instalar as dependências

### 6.2 Passos para Execução

1. Clone o repositório
2. Inicie o servidor com `npm start`
3. Teste as rotas de listagem paginada usando Insomnia ou Postman

---

## 7. Vídeo da Execução do Código

<video width="800" controls>
  <source src="assets/explicacao.mp4" type="video/mp4">
  Seu navegador não suporta a tag de vídeo.
</video>

---

## 8. Conclusões da Implementação

A implementação do padrão Facade contribui para garantir organização, centralização da lógica de negócio e escalabilidade no backend.
Com ele, é possível evoluir o sistema de forma sustentável, facilitando a manutenção e a adição de novas funcionalidades.

A utilização do GoFs Facade mostra a importância dos padrões de projeto na construção de sistemas robustos, modulares e que facilita manutenções futuras, contribuindo para um sistema sólido para futuras expansões.

## 9. Referências Bibliográficas

>SERRANO, Milene. Arquitetura e Desenho de Software - Aula GoFs Comportamentais. Universidade de Brasília (UnB), Campus Gama. [Material de Aula].

>REFACTORING.GURU. Padrões de Projeto. Disponível em: https://refactoring.guru/pt-br/design-patterns. Acesso em: 22 de outubro de 2025.

> GAMMA, E. et al. Padrões de Projeto: Soluções Reutilizáveis de Software Orientado a Objetos. Porto Alegre: Bookman, 1995.

## Histórico de Versões
| Versão | Alteração | Responsável | Data | Revisor |  Detalhes da Revisão | Data da Revisão |
|--------|-----------|-------------|------|---------|----------------------|-----------------|
| 1.0 | Criação inicial da página | [Brenno Oliveira](https://github.com/Brenno-Silva01) | 23/10/2025 | [Mateus Siqueira](https://github.com/siqueira-prog) | Revisão ortográfica e ajustes no layout | 23/10/2025 |
| 1.1 | Adição da metódologia e senso crítico | [Brenno Oliveira](https://github.com/Brenno-Silva01) | 23/10/2025 | [Mateus Siqueira](https://github.com/https://github.com/siqueira-prog) | revisado, sem alterações | 23/10/2025 |
| 1.2 | Adição do tópico Como executar e Conclusão | [Mateus Siqueira](https://github.com/siqueira-prog) | 23/10/2025 | [Brenno Oliveira](https://github.com/Brenno-Silva01) | Ajuste na formatação de como executar | 23/10/2025 |
| 2.0 | Feito ajustes na estrutura e tópicos | [Brenno Oliveira](https://github.com/Brenno-Silva01) | 23/10/2025 | [Mateus Siqueira](https://github.com/siqueira-prog) | --- | 23/10/2025 |