# 3.2.1 Bridge

## 3.2.1.1. Introdução

O padrão de projeto Bridge é uma solução estrutural que busca separar uma classe em duas hierarquias independentes: abstração e implementação. Ele surge para resolver o problema do crescimento exponencial de subclasses quando tentamos estender uma hierarquia em múltiplas dimensões, como no caso de formas geométricas e cores. Ao invés de depender exclusivamente de herança, o Bridge utiliza composição, permitindo que uma classe delegue parte de seu comportamento a outra, tornando o sistema mais flexível e fácil de manter. Com isso, é possível evoluir cada hierarquia independentemente, adicionando novas funcionalidades sem modificar o código existente, trazendo organização e escalabilidade para aplicações complexas.

Ele é utilizado em situações onde é necessário:

- Separar a lógica de alto nível (abstração) da lógica de baixo nível (implementação);
- Facilitar a extensão de abstrações e implementações sem alterar o código existente;
- Reduzir o acoplamento entre camadas de um sistema.

## 3.2.1.2. Metodologia

### 3.2.1.2.1 Estrutura do Padrão no Projeto

O padrão Bridge foi implementado no projeto com os seguintes componentes:

1. Abstraction: Define a interface de alto nível que utiliza as implementações.
2. RefinedAbstraction: Extensões da abstração que adicionam funcionalidades específicas.
3. Implementor: Interface que define as operações de baixo nível.
4. ConcreteImplementor: Implementações concretas da interface Implementor.

### 3.3.1.2.2 Arquitetura do Sistema

No projeto o Bridge é aplicado à persistência de dados: a abstração é representada pela classe PersistenciaTarefa, que define o contrato de operações (CRUD e conversão de tipo) esperado pela camada de domínio/serviço, enquanto as implementações concretas PersistenciaMongoDB e PersistenciaMock encapsulam os detalhes do armazenamento (Mongo). Serviços e controllers dependem apenas da abstração e recebem a implementação apropriada por injeção.

## 3.2.1.3. Modelagem

O diagrama abaixo ilustra a aplicação do padrão de projeto Bridge no contexto do nosso sistema. Nele, a classe Tarefa representa a abstração, responsável por operações como editar(), remover() e concluir(), enquanto a interface BancoDeDados e sua implementação concreta MongoDb compõem a implementação.

<center><img width="718" height="424" alt="Image" src="https://github.com/user-attachments/assets/f5861053-e6d6-4e8d-953d-03be76da04f9" /></center>
<center> Autores: Millena e Yasmim </center>

## 3.2.1.4. Código

### 3.2.1.4.1 Estrutura de Implementação

A implementação foi organizada na seguinte estrutura de arquivos e diretórios:

```
backend/src/services/ 
├── PersistenciaTarefa.js
```

#### 3.2.1.4.1.1 Abstração - PersistenciaTarefa

Define o contrato de persistência que a camada de serviços usa (métodos CRUD e conversão de tipo).

**Arquivo:** `backend/src/services/PersistenciaTarefa.js`

```javascript
// trechos extraídos de PersistenciaTarefa.js (veja o arquivo completo no backend)
export class PersistenciaTarefa {
  async salvar(tarefa) { throw new Error('Método salvar deve ser implementado'); }
  async buscarPorId(id) { throw new Error('Método buscarPorId deve ser implementado'); }
  async buscarTodos() { throw new Error('Método buscarTodos deve ser implementado'); }
  async atualizar(id, dados) { throw new Error('Método atualizar deve ser implementado'); }
  async deletar(id) { throw new Error('Método deletar deve ser implementado'); }
  async converterTipo(tarefaAtual, novoTipo, dadosAtualizacao) { throw new Error('Método converterTipo deve ser implementado'); }
}
```
#### 3.2.1.4.1.2 Implementor Concreto — PersistenciaMongoDB

Implementa o contrato usando o modelo Mongoose e uma fábrica de tarefas para recriar instâncias ao converter tipo.

**Arquivo:** `backend/src/services/PersistenciaTarefa.js`

```javascript
export class PersistenciaMongoDB extends PersistenciaTarefa {
  constructor(modeloTarefa, fabricaTarefas) {
    super();
    this.modelo = modeloTarefa;
    this.fabricaTarefas = fabricaTarefas;
  }

  async salvar(tarefa) { return await tarefa.save(); }

  async buscarPorId(id) {
    const tarefa = await this.modelo.findOne({ id: id });
    if (!tarefa) throw new Error('Tarefa não encontrada');
    return tarefa;
  }

  async atualizar(id, dados) {
    const tarefa = await this.buscarPorId(id);
    tarefa.editar(dados);
    return await tarefa.save();
  }

  async converterTipo(tarefaAtual, novoTipo, dadosAtualizacao) {
    // lógica de construção da nova tarefa usando fabricaTarefas e transação com mongoose
    // (veja implementation completa no arquivo)
  }
}
```

#### 3.2.1.4.1.3 Implementor Concreto — PersistenciaMock

Implementação em memória usada para testes e desenvolvimento local, mantendo a mesma interface.

```javascript
export class PersistenciaMock extends PersistenciaTarefa {
  constructor() {
    super();
    this.tarefas = new Map();
  }

  async salvar(tarefa) { this.tarefas.set(tarefa.id, { ...tarefa }); return tarefa; }

  async buscarPorId(id) {
    const tarefa = this.tarefas.get(id);
    if (!tarefa) throw new Error('Tarefa não encontrada');
    return tarefa;
  }

  async atualizar(id, dados) {
    const tarefa = await this.buscarPorId(id);
    const tarefaAtualizada = { ...tarefa, ...dados, atualizadoEm: new Date() };
    this.tarefas.set(id, tarefaAtualizada);
    return tarefaAtualizada;
  }

  async converterTipo(tarefaAtual, novoTipo, dadosAtualizacao) {
    const dadosAtualizados = { ...dadosAtualizacao, tipo: novoTipo, atualizadoEm: new Date() };
    return await this.atualizar(tarefaAtual.id, dadosAtualizados);
  }
}
```

#### 3.2.1.4.1.4 Integração com Serviços/Controllers

Serviços (ex.: TarefaService) devem receber uma instância de PersistenciaTarefa (PersistenciaMongoDB ou PersistenciaMock) por injeção; controllers instanciam ou resolvem a implementação adequada (ex.: com base em NODE_ENV) e delegam operações ao serviço — dessa forma a camada de negócio fica desacoplada do armazenamento.

## 3.2.1.6. Referências

>SERRANO, Milene. Arquitetura e Desenho de Software - Aula GoFs Estruturais. Universidade de Brasília (UnB), Campus Gama. [Material de Aula].

>REFACTORING.GURU. Bridge. Disponível em: https://refactoring.guru/pt-br/design-patterns/bridge. Acesso em: 22 de outubro de 2025.

## 3.2.1.7. Histórico de Versões

| Versão | Alteração | Responsável | Data | Revisor |  Detalhes da Revisão | Data da Revisão |
|--------|-----------|-------------|------|---------|----------------------|-----------------|
| 1.0 | Introdução, metodologia e aplicação do bridge |  [Millena](https://github.com/MillenaQueiroz) [Yasmim Rosa](https://github.com/yaskisoba) | 23/10/2025 | [NOME](https://github.com/SEUGITHUB) | ---  | XX/XX/XX |