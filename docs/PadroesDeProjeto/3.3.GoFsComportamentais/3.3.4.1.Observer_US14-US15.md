# Observer

## Introdu√ß√£o

O padr√£o **Observer**, classificado como um padr√£o comportamental pelo Gang of Four (GoF), define uma depend√™ncia um-para-muitos entre objetos, de modo que, quando um objeto muda de estado, todos os seus dependentes s√£o notificados e atualizados automaticamente. No contexto do projeto "O que planejo fazer", este padr√£o √© ideal para gerenciar eventos e notifica√ß√µes, permitindo que diferentes partes da aplica√ß√£o reajam a mudan√ßas de estado de forma desacoplada.

### Objetivo

O principal objetivo da aplica√ß√£o do padr√£o **Observer** √© permitir que componentes diferentes da aplica√ß√£o reajam a eventos espec√≠ficos (como o registro de um novo usu√°rio) sem que esses componentes estejam diretamente acoplados. Isso promove a flexibilidade, a extensibilidade e a manutenibilidade do sistema.

As metas fundamentais incluem:

*   **Baixo acoplamento:** Reduzir a depend√™ncia direta entre os objetos que geram eventos (sujeitos) e os objetos que reagem a eles (observadores), tornando o sistema mais modular.
*   **Extensibilidade:** Facilitar a adi√ß√£o de novos observadores (ex: um servi√ßo de notifica√ß√£o por SMS, um servi√ßo de an√°lise de dados) sem a necessidade de modificar o c√≥digo do sujeito existente, permitindo que novas funcionalidades de notifica√ß√£o ou rea√ß√£o sejam facilmente incorporadas.
*   **Reatividade:** Permitir que a aplica√ß√£o responda de forma din√¢mica a mudan√ßas de estado importantes, garantindo que as informa√ß√µes relevantes sejam propagadas para todos os interessados em tempo real.
*   **Reutiliza√ß√£o de c√≥digo:** Observadores e sujeitos podem ser reutilizados em diferentes contextos, j√° que sua intera√ß√£o √© definida por uma interface comum.

### Metodologia

O processo de aplica√ß√£o do padr√£o **Observer** no projeto seguiu uma abordagem estruturada:

#### Identifica√ß√£o dos candidatos ideais

Com base na arquitetura do projeto "O que planejo fazer", foi identificado o seguinte componente que se beneficiaria do padr√£o Observer:

*   **Notifica√ß√µes de Registro de Novo Usu√°rio (Back-end Node.js):** Quando um novo usu√°rio se registra na aplica√ß√£o, diferentes servi√ßos podem precisar ser notificados para realizar a√ß√µes subsequentes (ex: enviar e-mail de boas-vindas, registrar o evento em um log, integrar com um CRM).

#### Defini√ß√£o do ciclo de vida da inst√¢ncia

O ciclo de vida dos sujeitos e observadores √© independente. O sujeito (`AuthSubject`) existe enquanto houver eventos para serem observados. Os observadores (`EmailService`, `LogService`) s√£o instanciados e registrados no sujeito, permanecendo ativos para receber notifica√ß√µes at√© serem desregistrados ou a aplica√ß√£o ser encerrada.

#### Planejamento da implementa√ß√£o

Os princ√≠pios para a implementa√ß√£o do Observer foram definidos:

*   **Sujeito (Subject):** Define m√©todos para se inscrever (`subscribe`) e notificar (`notify`) observadores.
*   **Observador (Observer):** Define um m√©todo de atualiza√ß√£o (`update`) que ser√° chamado pelo sujeito quando ocorrer uma mudan√ßa de estado.
*   **Sujeito Concreto (Concrete Subject):** Mant√©m uma lista de observadores e notifica-os quando seu estado muda (neste caso, o `AuthSubject` ao registrar um novo usu√°rio).
*   **Observador Concreto (Concrete Observer):** Implementa a interface do observador e reage √†s notifica√ß√µes do sujeito (neste caso, `EmailService` e `LogService`).


### Modelagem

![Modelagem ‚Äî observer](../../assets/observer.png)

A modelagem visualiza a implementa√ß√£o do padr√£o Observer no sistema de registro de usu√°rios. Ela √© composta pelos seguintes elementos principais:

#### AuthController (O Cliente)
- Classe que inicia o processo
- Porta de entrada do sistema
- Aciona o mecanismo de notifica√ß√£o quando um novo usu√°rio √© criado
- Possui depend√™ncia com o AuthSubject atrav√©s de uma rela√ß√£o flex√≠vel (linha pontilhada)

#### AuthSubject (O Sujeito)
- Elemento central do padr√£o
- Mant√©m uma lista de "observers" (-observers: List<Observer>)
- Fornece m√©todos para:
  - Gerenciar a lista de observadores (subscribe)
  - Notificar observadores (notify)
- Respons√°vel por distribuir as notifica√ß√µes para todos os inscritos

#### Observer (A Interface)
- Define o contrato que todos os observadores devem seguir
- Especifica o m√©todo update(user) que deve ser implementado
- Permite que o AuthSubject notifique qualquer observador de forma padronizada

#### EmailService e LogService (Os Observadores Concretos)
- Classes que implementam a interface Observer
- Cada uma possui sua pr√≥pria implementa√ß√£o do m√©todo update(user)
- Responsabilidades espec√≠ficas:
  - EmailService: envia e-mails
  - LogService: registra logs
- Mant√™m associa√ß√£o direta com o AuthSubject

#### User (O Objeto de Dados)
- Representa a entidade que cont√©m as informa√ß√µes do usu√°rio
- Transmitido do sujeito para os observadores durante as notifica√ß√µes

#### Fluxo de Funcionamento
1. AuthController cria um User
2. AuthController chama notify(user) no AuthSubject
3. AuthSubject percorre sua lista de observers
4. Cada observer (EmailService, LogService) recebe update(user)
5. Os observers executam suas a√ß√µes espec√≠ficas independentemente

### Implementa√ß√£o (Node.js)

**Back-end (Node.js - Notifica√ß√µes de Registro de Novo Usu√°rio)**

Este exemplo demonstra como o padr√£o Observer pode ser usado para notificar diferentes servi√ßos quando um novo usu√°rio √© registrado. O `AuthSubject` atua como o Sujeito, e `EmailService` e `LogService` s√£o os Observadores.

```javascript
// backend/src/events/AuthObserver.js
class AuthSubject {
  constructor() {
    this.observers = [];
  }
  subscribe(observer) {
    this.observers.push(observer);
  }
  notify(user) {
    this.observers.forEach(observer => observer.update(user));
  }
}

class EmailService {
  update(user) {
    console.log(`‚úâÔ∏è SIMULA√á√ÉO: Enviando e-mail de boas-vindas para ${user.email}`);
    // L√≥gica real para enviar e-mail
  }
}

class LogService {
  update(user) {
    console.log(`üìù LOG: Novo usu√°rio cadastrado com sucesso - ${user.email}`);
    // L√≥gica real para registrar o evento em um sistema de log
  }
}

const authSubject = new AuthSubject();
authSubject.subscribe(new EmailService());
authSubject.subscribe(new LogService());

export default authSubject;
```
**Front-end (React - Acionamento do Evento)**
No front-end, o componente RegisterForm √© o ponto de contato que aciona o evento de registro. Uma vez que a requisi√ß√£o POST √© bem-sucedida, o back-end (onde o Observer est√° implementado) √© respons√°vel por notificar os observadores.

```javascript
// src/components/RegisterForm.jsx
import { useState } from 'react';
import axios from 'axios';

function RegisterForm({ onRegisterSuccess }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');
    setSuccess('');

    try {
      // Requisi√ß√£o que aciona o Controller no Back-end, que por sua vez, notifica o Observer
      await axios.post('http://localhost:3333/api/register', {
        email,
        password,
      });
      setSuccess('Cadastro realizado com sucesso! Voc√™ j√° pode fazer o login.');
      onRegisterSuccess(); 
    } catch (err) {
      setError(err.response?.data?.error || 'Erro ao cadastrar.');
    } finally {
      setLoading(false);
    }
  };

  // ... (restante do JSX do formul√°rio)
}

export default RegisterForm;
```

**Integra√ß√£o ao sistema**

O `authSubject` √© importado no `AuthController` e utilizado ap√≥s o registro bem-sucedido de um novo usu√°rio para notificar todos os observadores inscritos.

```javascript
// backend/src/controllers/AuthController.js
import User from '../models/User.js';
import authSubject from '../events/AuthObserver.js';
import jwt from 'jsonwebtoken';

class AuthController {
  async register(req, res) {
    try {
      const { email, password } = req.body;
      if (!email || !password) {
        return res.status(400).json({ error: 'Email e senha s√£o obrigat√≥rios.' });
      }
      const newUser = await User.create({ email, password });
      authSubject.notify(newUser); // Notifica os observadores ap√≥s o registro
      res.status(201).json({ message: 'Usu√°rio cadastrado com sucesso!', user: newUser });
    } catch (error) {
      if (error.code === 11000) {
        return res.status(409).json({ error: 'Este e-mail j√° est√° em uso.' });
      }
      res.status(500).json({ error: 'Erro ao registrar usu√°rio.' });
    }
  }

  async login(req, res) {
    // ... (c√≥digo do login)
  }
}

export default new AuthController();
```
Exemplo de uso no controller (ap√≥s criar usu√°rio):

```javascript
// ... dentro de AuthController.register
const newUser = await User.create({ email, password });
authSubject.notify(newUser);
res.status(201).json({ message: 'Usu√°rio cadastrado com sucesso!', user: newUser });
```

Como testar (cadastro):
- Rodar o backend (`npm run dev`).
- Executar:

```bash
curl -X POST http://localhost:3333/api/register \
  -H "Content-Type: application/json" \
  -d '{"email":"teste@exemplo.com","password":"senha123"}'
```

Resultados esperados:
- Resposta JSON confirmando cria√ß√£o.
- Mensagens no console vindas do EmailService e LogService.
- Usu√°rio criado na cole√ß√£o `users` do MongoDB.

---

### Resultado Final

A aplica√ß√£o do padr√£o **Observer** no projeto "O que planejo fazer" resultou em um sistema mais **flex√≠vel, modular e reativo**. A capacidade de notificar m√∫ltiplos componentes sobre o registro de novos usu√°rios sem criar depend√™ncias diretas entre eles melhora significativamente a manutenibilidade e a extensibilidade da aplica√ß√£o. Isso permite que novas funcionalidades, como integra√ß√£o com CRM ou an√°lise de dados de usu√°rio, sejam adicionadas com facilidade, reagindo a eventos existentes sem a necessidade de modificar a l√≥gica central de autentica√ß√£o.

## V√≠deo Explicativo

[V√≠deo Observer](https://www.youtube.com/watch?v=S9ws9G3clb0)

## Justificativa de Uso

*   O **Observer para Notifica√ß√µes de Registro de Usu√°rio (Node.js)** permite que diferentes m√≥dulos (servi√ßo de e-mail, servi√ßo de log) reajam de forma independente ao evento de registro de um novo usu√°rio. Isso evita que o `AuthController` precise conhecer e chamar diretamente cada um desses servi√ßos, reduzindo o acoplamento e tornando o sistema mais f√°cil de estender com novas funcionalidades de p√≥s-registro.
*   O padr√£o Observer √© ideal para cen√°rios onde um objeto precisa notificar muitos outros objetos sobre mudan√ßas de estado, mas n√£o quer ter um conhecimento profundo sobre esses objetos. Isso √© crucial para construir aplica√ß√µes escal√°veis e de f√°cil manuten√ß√£o, onde novas funcionalidades podem ser adicionadas como observadores sem impactar o c√≥digo existente do sujeito.


## Hist√≥rico de Vers√µes
| Vers√£o | Altera√ß√£o | Respons√°vel | Data | Revisor |  Detalhes da Revis√£o | Data da Revis√£o |
|--------|-----------|-------------|------|---------|----------------------|-----------------|
| 1.0 | documenta√ß√£o geral da p√°giina | [Maria Clara](https://github.com/alvezclari) | 23/10/2025 |Nathan Abreu | Corrigindo links |23/10/2025  |
| 1.1 | adicionando front end| [Maria Clara](https://github.com/alvezclari) | 23/10/2025 |Nathan Abreu | Corrigindo links |23/10/2025  |
| 1.2 | Corrigindo e revisando DOCS | [Nathan Abreu](https://github.com/nateejpg) | 23/10/2025 | |  |  |

