# 3.1.3.1. Padrão GOF: Iterator

## 1. Introdução

O padrão de projeto Iterator pertence ao grupo dos padrões comportamentais e tem como propósito principal fornecer uma maneira uniforme de percorrer os elementos de uma coleção, sem expor sua estrutura interna.  
Sua utilização promove o encapsulamento e a separação de responsabilidades, permitindo que diferentes coleções possam ser acessadas de forma sequencial e independente de sua implementação interna (GAMMA et al., 1995).

No contexto do projeto "O que planejo fazer", o Iterator foi aplicado para gerenciar a listagem paginada de tarefas e categorias, otimizando a navegação entre grandes volumes de dados e melhorando o desempenho do sistema.  
Essa aplicação garante uma interação fluida no backend e uma experiência mais eficiente para o usuário, permitindo a expansão futura do sistema sem comprometer sua estrutura.

---

## 2. Metodologia

A implementação do padrão Iterator seguiu as seguintes etapas metodológicas:

1. **Análise das Entidades:**  
   Foram identificadas as entidades *Tarefa* e *Categoria* como candidatas para aplicação do Iterator, considerando a necessidade de paginação e controle de grandes listas de dados.

2. **Modelagem da Solução:**  
   Definiu-se a criação de iterators específicos para cada entidade, encapsulando a lógica de navegação, paginação e filtragem.

3. **Implementação:**  
   Os iterators foram implementados como módulos independentes, garantindo que os *controllers* e *services* pudessem consumir coleções de forma consistente e desacoplada.

4. **Validação e Testes:**  
   Testes foram realizados com o *Insomnia* para assegurar que a paginação funcionasse corretamente, mantendo desempenho e integridade das respostas.

---

## 3. Participação, Colaboração e Senso Crítico

| Matrícula | Aluno |
|------------|--------|
| 19/0085045 | Brenno Oliveira |
| 20/0024787 | Mateus Siqueira |

O desenvolvimento e aplicação do padrão Iterator foram conduzidos de maneira colaborativa pelos alunos **Brenno Oliveira** e **Mateus Siqueira**, com reuniões via *Google Meet* e revisões conjuntas de código.  

Durante o processo, foram debatidos aspectos técnicos sobre **eficiência na paginação**, **reuso de código** e **adesão aos princípios SOLID**, resultando em um design limpo, modular e escalável.  
A cooperação foi essencial para aprimorar a tomada de decisões e garantir a consistência entre os módulos desenvolvidos.  

Além disso, a reflexão crítica sobre o uso do Iterator demonstrou que a adoção de padrões de projeto não apenas simplifica a manutenção, mas também favorece a **evolução sustentável do software**, fortalecendo a maturidade técnica da equipe.

---

## 4. Justificativa da Decisão Arquitetural

A escolha pelo uso do padrão Iterator foi motivada pelos seguintes fatores:

- **Facilidade de navegação:** permite percorrer coleções extensas sem expor detalhes internos.  
- **Paginação eficiente:** melhora o desempenho e evita sobrecarga no servidor.  
- **Flexibilidade para filtragem:** facilita a implementação de filtros personalizados e buscas dinâmicas.  
- **Isolamento de responsabilidades:** separa a lógica de navegação da lógica de negócio, favorecendo a testabilidade e manutenção.  
- **Escalabilidade:** prepara o sistema para lidar com volumes de dados crescentes de forma segura e organizada.  

---

## 5. Modelagem do Iterator

![COLOCAR DIAGRAMA BEM AQUI](diagrama_iterator)

O diagrama acima ilustra a estrutura empregada para paginação e navegação das entidades *Tarefa* e *Categoria* por meio do padrão Iterator.

---

## 6. Informações Técnicas e Implementação

### 6.1 Tecnologias Utilizadas

- JavaScript  
- Node.js  
- Mongoose (para persistência no MongoDB)  
- Insomnia/Postman (para testes e validação)  

---

### 6.2 Estrutura da Implementação

#### 6.2.1 Iterator de Categoria

Responsável por paginar e navegar pelas categorias, permitindo filtragem e controle de páginas.

```javascript
// src/controllers/iterators/CategoriaIterator.js
class CategoriaIterator {
  constructor(categorias, page = 1, limit = 5) {
    this.categorias = categorias;
    this.page = page;
    this.limit = limit;
    this.index = (page - 1) * limit;
  }

  next() {
    if (this.index < this.categorias.length && this.index < this.page * this.limit) {
      return { value: this.categorias[this.index++], done: false };
    }
    return { done: true };
  }

  reset() {
    this.index = (this.page - 1) * this.limit;
  }
}

export default CategoriaIterator;

```

### 6.2.2 Iterator de Tarefa

Responsável por iterar e paginar as tarefas, garantindo consistência com a lógica de categorias.

```javascript
// src/controllers/iterators/TarefaIterator.js
class TarefaIterator {
  constructor(tarefas, page = 1, limit = 5) {
    this.tarefas = tarefas;
    this.page = page;
    this.limit = limit;
    this.index = (page - 1) * limit;
  }

  next() {
    if (this.index < this.tarefas.length && this.index < this.page * this.limit) {
      return { value: this.tarefas[this.index++], done: false };
    }
    return { done: true };
  }

  reset() {
    this.index = (this.page - 1) * this.limit;
  }
}

export default TarefaIterator;

```

### 6.2.3 Utilização nos Controllers

Os controllers utilizam os iterators para retornar dados paginados e filtrados, otimizando a navegação e reduzindo a carga de dados trafegados.

```javascript
// Exemplo no CategoriaController.js
import CategoriaIterator from './iterators/CategoriaIterator.js';
import Categoria from '../models/Categoria.js';

class CategoriaController {
  async listarCategoriasPaginadas(req, res) {
    try {
      const { page = 1, limit = 5 } = req.query;
      const categorias = await Categoria.find().sort({ criadoEm: -1 });
      const iterator = new CategoriaIterator(categorias, Number(page), Number(limit));

      let paginadas = [];
      let result = iterator.next();
      while (!result.done) {
        paginadas.push(result.value);
        result = iterator.next();
      }

      res.json({ categorias: paginadas, pagination: { page, limit } });
    } catch (error) {
      res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }
}

```

## 7. Como Executar a Implementação

### 7.1 Pré-requisitos

- Node.js instalado
- MongoDB rodando localmente ou em nuvem
- Executar `npm install` para instalar as dependências

### 7.2 Passos para Execução

1. Clone o repositório
2. Inicie o servidor com `npm start`
3. Teste as rotas de listagem paginada usando Insomnia ou Postman

---

## 8. Vídeo da Execução do Código

[INSERIR O VÍDEO DE DEMONSTRAÇÃO AQUI]

---

## 9. Conclusões da Implementação

A implementação do padrão Iterator tem grande valor pois pode garantir navegação eficiente, escalabilidade e modularidade no sistema.  
Com ele, é possível manipular coleções de forma mais controlada e extensível, preparando o backend para lidar com grandes volumes de dados.

A aplicação mostra a importância dos padrões de projeto na construção de sistemas organizados, reutilizáveis e de fácil manutenção, promovendo uma arquitetura sólida e sustentável para evoluções futuras.

---

## 10. Referências Bibliográficas

>SERRANO, Milene. Arquitetura e Desenho de Software - Aula GoFs Comportamentais. Universidade de Brasília (UnB), Campus Gama. [Material de Aula].

>REFACTORING.GURU. Padrões de Projeto. Disponível em: https://refactoring.guru/pt-br/design-patterns. Acesso em: 22 de outubro de 2025.

> GAMMA, E. et al. Padrões de Projeto: Soluções Reutilizáveis de Software Orientado a Objetos. Porto Alegre: Bookman, 1995.

## Histórico de Versões
| Versão | Alteração | Responsável | Data | Revisor |  Detalhes da Revisão | Data da Revisão |
|--------|-----------|-------------|------|---------|----------------------|-----------------|
| 1.0 | Criação inicial da página | [Brenno Oliveira](https://github.com/Brenno-Silva01) | 23/10/2025 | [Mateus Siqueira](https://github.com/siqueira-prog) | Revisão ortográfica e ajustes no layout | 23/10/2025 |
| 1.1 | Adição da metódologia e senso crítico | [Brenno Oliveira](https://github.com/Brenno-Silva01) | 23/10/2025 | [Mateus Siqueira](https://github.com/https://github.com/siqueira-prog) | revisado, sem alterações | 23/10/2025 |
| 1.2 | Adição do tópico Como executar e Conclusão | [Mateus Siqueira](https://github.com/siqueira-prog) | 23/10/2025 | [Brenno Oliveira](https://github.com/Brenno-Silva01) | Ajuste na formatação de como executar | 23/10/2025 |
| 2.0 | Feito ajustes na estrutura e tópicos | [Brenno Oliveira](https://github.com/Brenno-Silva01) | 23/10/2025 | [Mateus Siqueira](https://github.com/siqueira-prog) | --- | 23/10/2025 |