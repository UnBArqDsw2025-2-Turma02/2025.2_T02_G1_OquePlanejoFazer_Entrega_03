# 3.1.3.1. Padrão GOF: Iterator

## 1. Introdução

O padrão de projeto Iterator pertence ao grupo dos padrões comportamentais e tem como propósito principal fornecer uma maneira uniforme de percorrer os elementos de uma coleção, sem expor sua estrutura interna.  
Sua utilização promove o encapsulamento e a separação de responsabilidades, permitindo que diferentes coleções possam ser acessadas de forma sequencial e independente de sua implementação interna (GAMMA et al., 1995).

No contexto do projeto "O que planejo fazer", o Iterator foi aplicado para gerenciar a listagem paginada de tarefas e categorias, otimizando a navegação entre grandes volumes de dados e melhorando o desempenho do sistema.  
Essa aplicação garante uma interação fluida no backend e uma experiência mais eficiente para o usuário, permitindo a expansão futura do sistema sem comprometer sua estrutura.

---

## 2. Metodologia

A implementação do padrão Iterator seguiu as seguintes etapas metodológicas:

1. **Análise das Entidades:**  
   Foram identificadas as entidades *Tarefa* e *Categoria* da [US07 - Criar listas/categorias](https://unbarqdsw2025-2-turma02.github.io/2025.2_T02_G1_OquePlanejoFazer_Entrega_02/#/Modelagem/2.5.2.DeclaracaoRequisitos) como candidatas para aplicação do Iterator, considerando a necessidade de paginação e controle de grandes listas de dados.

2. **Modelagem da Solução:**  
   Definiu-se a criação de iterators específicos para cada entidade, encapsulando a lógica de navegação, paginação e filtragem.

3. **Implementação:**  
   Os iterators foram implementados como módulos independentes, garantindo que os *controllers* e *services* pudessem consumir coleções de forma consistente e desacoplada.

4. **Validação e Testes:**  
   Testes foram realizados com o *Insomnia* para assegurar que a paginação funcionasse corretamente, mantendo desempenho e integridade das respostas.

---

## 3. Participação, Colaboração e Senso Crítico

| Matrícula | Aluno |
|------------|--------|
| 19/0085045 | Brenno Oliveira |
| 20/0024787 | Mateus Siqueira |

O desenvolvimento e aplicação do padrão Iterator foram conduzidos de maneira colaborativa pela dupla Brenno Oliveira e Mateus Siqueira, com reuniões via *Google Meet* e revisões conjuntas de código.  

Durante o processo, foram debatidos qual seria o padrão GoFs comportamental mais interessante para se aplicar, chegando na decisão da utilização do Iterator, que resulta em um design limpo, modular e escalável.  
A cooperação foi essencial para aprimorar a tomada de decisões e troca de conhecimentos.  

Além disso, o uso do Iterator demonstrou que a adoção de padrões de projeto não apenas simplifica a manutenção, mas também favorece a evolução sustentável do software, fortalecendo a maturidade técnica da equipe.

---

## 4. Justificativa da Decisão Arquitetural

A escolha pelo uso do padrão Iterator foi motivada pelos seguintes fatores:

- **Facilidade de navegação:** permite percorrer coleções extensas sem expor detalhes internos.  
- **Paginação eficiente:** melhora o desempenho e evita sobrecarga no servidor.  
- **Flexibilidade para filtragem:** facilita a implementação de filtros personalizados e buscas dinâmicas.  
- **Isolamento de responsabilidades:** separa a lógica de navegação da lógica de negócio, favorecendo a testabilidade e manutenção.  
- **Escalabilidade:** prepara o sistema para lidar com volumes de dados crescentes de forma segura e organizada.  

---

## 5. Informações Técnicas e Implementação

### 5.1 Tecnologias Utilizadas

- JavaScript  
- Node.js  
- Mongoose (para persistência no MongoDB)  
- Insomnia/Postman (para testes e validação)  

---

### 5.2 Estrutura da Implementação

#### 5.2.1 Iterator de Categoria

Responsável por paginar e navegar pelas categorias, permitindo filtragem e controle de páginas.

```javascript
import Categoria from '../../models/Categoria.js';

class CategoriaIterator {
  constructor(filtro = {}, page = 1, limit = 5) {
    this.filtro = filtro;
    this.page = parseInt(page, 10);
    this.limit = parseInt(limit, 10);
    this.total = 0;
  }

  async getCurrentPage() {
    const skip = (this.page - 1) * this.limit;

    const categorias = await Categoria.find(this.filtro)
      .sort({ criadoEm: -1 })
      .skip(skip)
      .limit(this.limit);

    if (this.total === 0) {
      this.total = await Categoria.countDocuments(this.filtro);
    }

    return categorias;
  }

  hasNext() {
    return (this.page * this.limit) < this.total;
  }

  getPaginationInfo() {
    return {
      totalItems: this.total,
      totalPages: Math.ceil(this.total / this.limit),
      currentPage: this.page,
      hasNext: this.hasNext(),
    };
  }
}

export default CategoriaIterator;

```

### 5.2.2 Iterator de Tarefa

Responsável por iterar e paginar as tarefas, garantindo consistência com a lógica de categorias.

```javascript
import { Tarefa } from '../../models/Tarefa.js';

class TarefaIterator {
  constructor(filtro, page = 1, limit = 5) {
    this.filtro = filtro;
    this.page = parseInt(page, 10);
    this.limit = parseInt(limit, 10);
    this.total = 0;
  }

  // O método principal que busca a página de dados
  async getCurrentPage() {
    const skip = (this.page - 1) * this.limit;

    // Busca os documentos da página atual
    const tarefas = await Tarefa.find(this.filtro)
      .sort({ criadoEm: -1 })
      .skip(skip)
      .limit(this.limit)
      .populate('categoria');

    // Conta o total de documentos (apenas na primeira página para otimizar)
    if (this.total === 0) {
      this.total = await Tarefa.countDocuments(this.filtro);
    }

    return tarefas;
  }

  // Método para verificar se existe uma próxima página
  hasNext() {
    return (this.page * this.limit) < this.total;
  }

  // Método para obter informações de paginação
  getPaginationInfo() {
    return {
      totalItems: this.total,
      totalPages: Math.ceil(this.total / this.limit),
      currentPage: this.page,
      hasNext: this.hasNext(),
    };
  }
}

export default TarefaIterator;

```

### 5.2.3 Utilização nos Controllers

Os controllers utilizam os iterators para retornar dados paginados e filtrados, otimizando a navegação e reduzindo a carga de dados trafegados.

```javascript
import CategoriaService from '../services/CategoriaService.js';

class CategoriaController {
  async criarCategoria(req, res) {
    try {
      const { nome, cor } = req.body;
      if (!nome || !cor) {
        return res.status(400).json({ error: 'Nome e cor da categoria são obrigatórios' });
      }
      const categoria = await CategoriaService.criarCategoria(nome, cor);
      res.status(201).json({ message: 'Categoria criada com sucesso', categoria });
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }

  async listarCategorias(req, res) {
    try {
      const categorias = await CategoriaService.listarCategorias();
      res.json({ message: 'Categorias listadas com sucesso', categorias });
    } catch (error) {
      res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }

  async listarCategoriasPaginadas(req, res) {
    try {
      const { page = 1, limit = 5 } = req.query;
      const result = await CategoriaService.listarCategoriasPaginadas(Number(page), Number(limit));
      res.json(result);
    } catch (error) {
      res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }

  async editarCategoria(req, res) {
    try {
      const { id } = req.params;
      const { nome } = req.body;
      const categoria = await CategoriaService.editarCategoria(id, nome);
      res.json({ message: 'Categoria editada com sucesso', categoria });
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }

  async removerCategoria(req, res) {
    try {
      const { id } = req.params;
      const categoria = await CategoriaService.removerCategoria(id);
      res.json({ message: 'Categoria removida com sucesso', categoria });
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }
}

export default CategoriaController;

```

## 6. Como Executar a Implementação

### 6.1 Pré-requisitos

- Node.js instalado
- MongoDB rodando localmente ou em nuvem
- Executar `npm install` para instalar as dependências

### 6.2 Passos para Execução

1. Clone o repositório:
   ```bash
   git clone https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G1_OquePlanejoFazer_Entrega_03.git
   git checkout feat/listar_tarefas
   ```

2. Inicie o servidor:
   ```bash
   cd backend
   npm start
   ```

3. Teste as rotas de usando Insomnia:
   ```
   GET
   http://localhost:3333/api/categorias/paginadas
   GET
   http://localhost:3333/api/tarefas/
   ```

---

## 7. Vídeo da Execução do Código

<video width="800" controls>
  <source src="assets/explicacao.mp4" type="video/mp4">
  Seu navegador não suporta a tag de vídeo.
</video>

---

## 8. Conclusões da Implementação

A implementação do padrão Iterator tem grande valor pois pode garantir navegação eficiente, escalabilidade e modularidade no sistema.  
Com ele, é possível manipular coleções de forma mais controlada e extensível, preparando o backend para lidar com grandes volumes de dados.

A aplicação mostra a importância dos padrões de projeto na construção de sistemas organizados, reutilizáveis e de fácil manutenção, promovendo uma arquitetura sólida e sustentável para evoluções futuras.

---

## 9. Referências Bibliográficas

>SERRANO, Milene. Arquitetura e Desenho de Software - Aula GoFs Comportamentais. Universidade de Brasília (UnB), Campus Gama. [Material de Aula].

>REFACTORING.GURU. Padrões de Projeto. Disponível em: https://refactoring.guru/pt-br/design-patterns. Acesso em: 22 de outubro de 2025.

> GAMMA, E. et al. Padrões de Projeto: Soluções Reutilizáveis de Software Orientado a Objetos. Porto Alegre: Bookman, 1995.

## Histórico de Versões
| Versão | Alteração | Responsável | Data | Revisor |  Detalhes da Revisão | Data da Revisão |
|--------|-----------|-------------|------|---------|----------------------|-----------------|
| 1.0 | Criação inicial da página | [Brenno Oliveira](https://github.com/Brenno-Silva01) | 23/10/2025 | [Mateus Siqueira](https://github.com/siqueira-prog) | Revisão ortográfica e ajustes no layout | 23/10/2025 |
| 1.1 | Adição da metódologia e senso crítico | [Brenno Oliveira](https://github.com/Brenno-Silva01) | 23/10/2025 | [Mateus Siqueira](https://github.com/https://github.com/siqueira-prog) | revisado, sem alterações | 23/10/2025 |
| 1.2 | Adição do tópico Como executar e Conclusão | [Mateus Siqueira](https://github.com/siqueira-prog) | 23/10/2025 | [Brenno Oliveira](https://github.com/Brenno-Silva01) | Ajuste na formatação de como executar | 23/10/2025 |
| 2.0 | Feito ajustes na estrutura e tópicos | [Brenno Oliveira](https://github.com/Brenno-Silva01) | 23/10/2025 | [Mateus Siqueira](https://github.com/siqueira-prog) | --- | 23/10/2025 |