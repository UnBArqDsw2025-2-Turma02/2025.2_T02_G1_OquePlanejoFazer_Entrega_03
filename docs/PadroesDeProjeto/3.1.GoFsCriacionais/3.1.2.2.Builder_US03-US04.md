# 3.1.2.1. Padrão GOF: Builder

## 1. Introdução

O padrão de projeto Builder pertence ao grupo dos padrões criacionais e tem como principal objetivo separar a construção de um objeto complexo da sua representação, permitindo a criação de diferentes variações do mesmo objeto utilizando o mesmo processo de construção (GAMMA et al., 1995).

No contexto do projeto "O que Planejo Fazer", o Builder foi aplicado às funcionalidade de [priorização de tarefas (US03) e finalização de tarefas (US04)](https://unbarqdsw2025-2-turma02.github.io/2025.2_T02_G1_OquePlanejoFazer_Entrega_02/#/Modelagem/2.5.2.DeclaracaoRequisitos). Sua utilização possibilitou a criação de relatórios de conclusão de tarefa de forma estruturada e flexível, garantindo que cada parte do relatório (título, descrição, duração, data e status) fosse montada gradualmente e de maneira independente. No caso da priorização de tarefa, pela foi criado uma forma alternativa de criação de tarefa usando o builder.

Essa abordagem favorece a legibilidade, a manutenção e o reuso do código, especialmente quando o processo de construção de uma entidade envolve diversas etapas ou regras específicas de formatação.

---

## 2. Metodologia

A implementação do padrão Builder seguiu as seguintes etapas metodológicas:
**Na US04:**
1. **Análise das entidades:**  
Durante o processo de finalização da tarefa, foi identificado que o sistema precisava gerar um relatório detalhado de conclusão, contendo dados que variavam de acordo com o tipo de tarefa.

2. **Modelagem da solução:**  
Definiu-se um construtor (RelatorioTarefaBuilder) capaz de criar relatórios passo a passo, adicionando cada campo de forma encadeada, com métodos específicos para cada atributo relevante.

3. **Implementação:**  
A classe Builder foi desenvolvida de forma independente da entidade Tarefa, recebendo apenas os dados necessários para compor o relatório final.

4. **Validação Testes:**  
Foram realizados testes manuais e automatizados para garantir que diferentes tipos de tarefas resultassem em relatórios consistentes, válidos e formatados corretamente.

**Já na US03:**
1. **Análise das entidades:**
Já que a Prioridade de uma tarefa pode ser definida na criação e edição, foi criado um TaskBuilder, onde é possível criar cada pedaço de uma tarefa por vez.

3. **Modelagem da solução:**  
Definiu-se um construtor (TaskBuilder) capaz de criar Tarefas passo a passo, adicionando cada campo de forma encadeada, com métodos específicos para cada atributo relevante. Como alguns campos são obrigatórios, existe um limite para flexibilidade neste caso.

4. **Implementação:**  
A classe Builder foi desenvolvida de forma independente da entidade Tarefa, recebendo os campos que podem ser atribuídos com um valor de entrada.

5. **Validação Testes:**  
Foram realizados testes manuais para provar que o Builder funciona corretamente.
---

## 3. Participação, Colaboração e Senso Crítico

| Matrícula | Aluno |
|------------|--------|
| 22/1007582 | Camila Careli |
| 18/0113097 | Daniel Coimbra |

O desenvolvimento do padrão Builder foi conduzido de forma colaborativa, com trocas contínuas de ideias sobre como estruturar um relatório de forma desacoplada da lógica principal de finalização.

Durante o processo, foi discutida a importância de flexibilidade e reutilização, buscando alinhar o design com princípios do SOLID e Clean Code.
A reflexão sobre o uso do padrão mostrou que o Builder é essencial quando há necessidade de criar objetos complexos com muitas variações, garantindo clareza e expansibilidade futura.

---

## 4. Justificativa da Decisão Arquitetural

A decisão de aplicar o padrão Builder foi motivada pelos seguintes fatores:

- **Separação de responsabilidades:** evita que a entidade Tarefa assuma o papel de construir o relatório.

- **Flexibilidade:** permite criar diferentes formatos de relatórios sem alterar o código principal.

- **Reuso:** o mesmo Builder pode ser utilizado para gerar outros tipos de relatórios no futuro.

- **Leitura fluida:** o encadeamento de métodos (builder.adicionarX().adicionarY().build()) torna o código intuitivo.

- **Manutenção facilitada:** novas informações podem ser adicionadas sem comprometer o funcionamento atual.

---

## 5. Informações Técnicas e Implementação

### 5.1 Tecnologias Utilizadas
- **JavaScript**
- **Node.js**
- **VSCode**

### 5.2 Estrutura da Implementação

#### 5.2.1. Classe ```RelatorioTarefaBuilder```
Responsável por construir o relatório de conclusão de tarefa passo a passo, adicionando cada elemento separadamente.

```javascript
// src/services/RelatorioTarefaBuilder.js

class RelatorioTarefaBuilder {
  constructor() {
    // Inicializa o produto que será construído
    this.relatorio = {};
  }

  // Adiciona o título, com um valor padrão caso seja nulo.
  adicionarTitulo(titulo) {
    this.relatorio.titulo = titulo || 'Tarefa sem título';
    return this;
  }

  // Adiciona a descrição, com um valor padrão caso seja nula.
  adicionarDescricao(descricao) {
    this.relatorio.descricao = descricao || 'Tarefa sem descrição.';
    return this;
  }

  //Adiciona a data de finalização, formatando-a para o padrão PT-BR.
  adicionarDataFinalizacao(dataISO) {
    if (dataISO) {
      this.relatorio.dataFinalizacao = new Date(dataISO).toLocaleString('pt-BR', {
        dateStyle: 'short',
        timeStyle: 'short',
      });
    } else {
      this.relatorio.dataFinalizacao = 'Data não registrada';
    }
    return this;
  }

  // Adiciona a duração da tarefa, formatando-a em horas e minutos.
  adicionarDuracao(totalMinutos) {
    if (totalMinutos === null || totalMinutos === undefined || totalMinutos < 0) {
      this.relatorio.duracao = 'Duração não calculada';
      return this;
    }

    const horas = Math.floor(totalMinutos / 60);
    const minutos = totalMinutos % 60;
    this.relatorio.duracao = `${horas}h ${minutos}min`;
    return this;
  }

  // Retorna o objeto Relatório completo.
  build() {
    return this.relatorio;
  }
}

export default RelatorioTarefaBuilder;

```

#### 5.2.2. Utilização no Serviço de Finalização
```javascript
// src/services/TarefaService.js
import RelatorioTarefaBuilder from './RelatorioTarefaBuilder.js';

class TarefaService {
  // Calcula a diferença entre duas datas em minutos.
  _calcularDuracao(inicioISO, fimISO) {
    // Garante que temos dados válidos para calcular
    if (!inicioISO || !fimISO) {
      return -1; // Retorna um valor que o Builder saberá tratar
    }
    
    try {
      const inicio = new Date(inicioISO);
      const fim = new Date(fimISO);
      const diffMs = fim.getTime() - inicio.getTime(); // Diferença em milissegundos
      
      // Se a diferença for negativa, retorna 0
      if (diffMs < 0) {
        return 0;
      }

      // Converte milissegundos para minutos
      const diffMinutos = Math.round(diffMs / (1000 * 60));
      return diffMinutos;
    } catch (error) {
      console.error("Erro ao calcular duração:", error);
      return -1;
    }
  }

  // Finaliza uma tarefa e gera um relatório de conclusão.

  finalizarTarefa(tarefa) {
    // Lógica de negócio da US (atualizar o estado da tarefa)
    tarefa.finalizada = true;
    tarefa.dataFinalizacao = new Date().toISOString();

    // Lógica do Serviço: calcular os dados dinâmicos
    const duracaoEmMinutos = this._calcularDuracao(
      tarefa.dataInicio, 
      tarefa.dataFinalizacao
    );

    // Usar o Builder para construir o "Produto" (o Relatório)
    const relatorio = new RelatorioTarefaBuilder()
      .adicionarTitulo(tarefa.titulo)
      .adicionarDescricao(tarefa.descricao)
      .adicionarDataFinalizacao(tarefa.dataFinalizacao) // Passa o ISO
      .adicionarDuracao(duracaoEmMinutos) // Passa os minutos
      .build();

    console.log("Relatório gerado:", relatorio);

    // Retorna o produto final gerado
    return relatorio;
  }
}

export default TarefaService;

```

#### 5.2.3. Classe ```TaskBuilder```
```javascript
import { Tarefa } from "../models/Tarefa.js";

export class TaskBuilder {
  constructor() {
    this.tarefa = new Tarefa();
  }

  setTitulo(titulo) {
    this.tarefa.titulo = titulo;
    return this;
  }

  setPrioridade(prioridade) {
    this.tarefa.prioridade = prioridade;
    return this;
  }

  setDescricao(descricao) {
    this.tarefa.descricao = descricao;
    return this;
  }

  setCriadoEm(date = new Date()) {
    this.tarefa.criadoEm = date;
    return this;
  }

  setEstimativa(estimativa){
    this.tarefa.estimativa = estimativa;
    return this;
  }

  setAtualizadoEm(atualizadoEm){
    this.tarefa.atualizadoEm = atualizadoEm;
    return this;
  }

  setTipo(tipo){
    this.tarefa.tipo = tipo;
    return this;
  }
  
  setConcluida(concluida) {
    this.tarefa.concluida = concluida;
    return this;
  }

  build() {
    return this.tarefa;
  }
}
```
#### 5.2.4. Utilização como forma alternativa de criação de Tarefa
```javascript
import { TaskBuilder } from "../builders/TaskBuilder.js";
import { taskObserver } from "../../../frontend/src/observers/TaskObserver.js";
import { Tarefa } from "../models/Tarefa.js";


export async function buildTask(req, res) {
  try {
    const { titulo, prioridade, descricao, tipo, estimativa, concluida } = req.body;

    const task = new TaskBuilder()
      .setTitulo(titulo || "Mock Task Example")
      .setPrioridade(prioridade || "Alta")
      .setDescricao(descricao || "Generated from frontend")
      .setCriadoEm(new Date().toISOString())
      .setAtualizadoEm(new Date().toISOString())
      .setTipo(tipo || 'simples')
      .setEstimativa(estimativa || 100)
      .setConcluida(concluida || false)
      .build();
    await task.save();

    return res.status(201).json(task);
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: "Failed to create mock task" });
  }
}

```

## 6. Como Executar a Implementação

### 6.1 Pré-requisitos
- Node.js instalado
- Projeto configurado com a estrutura de pastas src/services

### 6.2 Passos para Execução
1. Clone o repositório:
    ```bash
    git clone https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G1_OquePlanejoFazer_Entrega_03.git
    git checkout feat/finalizar_tarefa

    ```

2. Inicie o servidor:
    ```bash
    cd backend
    npm install
    npm start
    ```

3. Teste as rotas de criação: Substitua ":id" pelo ID da tarefa que deseja finalizar.
    ```
    PUT /api/tarefas/:id/finalizar 
    ```
4. Teste a rota alternativa de criação de tarefa
    ```
    POST /mock-task
    ```
## 7. Video da Execução do Código
### 7.1 Vídeo da US03 - Daniel Coimbra:

[Video US03](https://youtu.be/XkqHGz475H4)


## 8. Conclusões da Implementação

A aplicação do padrão Builder na funcionalidade de finalização de tarefas trouxe maior organização e extensibilidade ao sistema.

O encapsulamento do processo de criação do relatório garantiu baixo acoplamento entre as classes, tornando o código mais legível e sustentável.

Além disso, a estrutura facilita futuras expansões, como geração de relatórios em PDF ou integração com APIs externas, sem alterar a lógica central da aplicação.

## 9. Referências Bibliográficas

>SERRANO, Milene. Arquitetura e Desenho de Software - Aula GoFs Criacionais. Universidade de Brasília (UnB), Campus Gama. [Material de Aula].

>REFACTORING.GURU. Padrões de Projeto. Disponível em: https://refactoring.guru/pt-br/design-patterns. Acesso em: 22 de outubro de 2025.

> GAMMA, E. et al. Padrões de Projeto: Soluções Reutilizáveis de Software Orientado a Objetos. Porto Alegre: Bookman, 1995.

## Histórico de Versões
| Versão | Alteração | Responsável | Data | Revisor |  Detalhes da Revisão | Data da Revisão |
|--------|-----------|-------------|------|---------|----------------------|-----------------|
| 1.0 | Criação da página e inserção de: introdução, metodologia, senso crítico, justificativa e código.  | [Camila Careli](https://github.com/camilascareli) | 23/10/2025 | [SEUGIT](https://github.com/SEUGITAQUI) | - | 24/XX/2025 |
| 1.1 | Adição da US 03.  | [Daniel Coimbra](https://github.com/DanielCoimbra) | 24/10/2025 | [SEUGIT](https://github.com/SEUGITAQUI) | - | XX/XX/2025 |
