# 3.1.2.1. Padrão GOF: Builder

## 1. Introdução

O padrão de projeto Builder pertence ao grupo dos padrões criacionais e tem como principal objetivo separar a construção de um objeto complexo da sua representação, permitindo a criação de diferentes variações do mesmo objeto utilizando o mesmo processo de construção (GAMMA et al., 1995).

No contexto do projeto "O que Planejo Fazer", o Builder foi aplicado à funcionalidade de finalização de tarefas (US04). Sua utilização possibilitou a criação de relatórios de conclusão de tarefa de forma estruturada e flexível, garantindo que cada parte do relatório (título, descrição, duração, data e status) fosse montada gradualmente e de maneira independente.

Essa abordagem favorece a legibilidade, a manutenção e o reuso do código, especialmente quando o processo de construção de uma entidade envolve diversas etapas ou regras específicas de formatação.

---

## 2. Metodologia

A implementação do padrão Builder seguiu as seguintes etapas metodológicas:

1. **Análise das entidades:**  
Durante o processo de finalização da tarefa, foi identificado que o sistema precisava gerar um relatório detalhado de conclusão, contendo dados que variavam de acordo com o tipo de tarefa.

2. **Modelagem da solução:**  
Definiu-se um construtor (RelatorioTarefaBuilder) capaz de criar relatórios passo a passo, adicionando cada campo de forma encadeada, com métodos específicos para cada atributo relevante.

3. **Implementação:**  
A classe Builder foi desenvolvida de forma independente da entidade Tarefa, recebendo apenas os dados necessários para compor o relatório final.

4. **Validação Testes:**  
Foram realizados testes manuais e automatizados para garantir que diferentes tipos de tarefas resultassem em relatórios consistentes, válidos e formatados corretamente.

---

## 3. Participação, Colaboração e Senso Crítico

| Matrícula | Aluno |
|------------|--------|
| 22/1007582 | Camila Careli |

O desenvolvimento do padrão Builder foi conduzido de forma colaborativa, com trocas contínuas de ideias sobre como estruturar um relatório de forma desacoplada da lógica principal de finalização.

Durante o processo, foi discutida a importância de flexibilidade e reutilização, buscando alinhar o design com princípios do SOLID e Clean Code.
A reflexão sobre o uso do padrão mostrou que o Builder é essencial quando há necessidade de criar objetos complexos com muitas variações, garantindo clareza e expansibilidade futura.

---

## 4. Justificativa da Decisão Arquitetural

A decisão de aplicar o padrão Builder foi motivada pelos seguintes fatores:

- **Separação de responsabilidades:** evita que a entidade Tarefa assuma o papel de construir o relatório.

- **Flexibilidade:** permite criar diferentes formatos de relatórios sem alterar o código principal.

- **Reuso:** o mesmo Builder pode ser utilizado para gerar outros tipos de relatórios no futuro.

- **Leitura fluida:** o encadeamento de métodos (builder.adicionarX().adicionarY().build()) torna o código intuitivo.

- **Manutenção facilitada:** novas informações podem ser adicionadas sem comprometer o funcionamento atual.

---

## 5. Modelagem do Builder

![COLOCAR DIAGRAMA BEM AQUI](diagrama_factory)

Diagrama de classes representando a aplicação do padrão Builder. O TarefaService (Cliente) utiliza o RelatorioTarefaBuilder (Builder) para construir o Relatorio (Produto) passo a passo.

---

## 6. Informações Técnicas e Implementação

### 6.1 Tecnologias Utilizadas
- **JavaScript**
- **Node.js**
- **VSCode**

### 6.2 Estrutura da Implementação

#### 6.2.1. Classe ```RelatorioTarefaBuilder```
Responsável por construir o relatório de conclusão de tarefa passo a passo, adicionando cada elemento separadamente.

```
// src/services/RelatorioTarefaBuilder.js

class RelatorioTarefaBuilder {
  constructor() {
    // Inicializa o produto que será construído
    this.relatorio = {};
  }

  // Adiciona o título, com um valor padrão caso seja nulo.
  adicionarTitulo(titulo) {
    this.relatorio.titulo = titulo || 'Tarefa sem título';
    return this;
  }

  // Adiciona a descrição, com um valor padrão caso seja nula.
  adicionarDescricao(descricao) {
    this.relatorio.descricao = descricao || 'Tarefa sem descrição.';
    return this;
  }

  //Adiciona a data de finalização, formatando-a para o padrão PT-BR.
  adicionarDataFinalizacao(dataISO) {
    if (dataISO) {
      this.relatorio.dataFinalizacao = new Date(dataISO).toLocaleString('pt-BR', {
        dateStyle: 'short',
        timeStyle: 'short',
      });
    } else {
      this.relatorio.dataFinalizacao = 'Data não registrada';
    }
    return this;
  }

  // Adiciona a duração da tarefa, formatando-a em horas e minutos.
  adicionarDuracao(totalMinutos) {
    if (totalMinutos === null || totalMinutos === undefined || totalMinutos < 0) {
      this.relatorio.duracao = 'Duração não calculada';
      return this;
    }

    const horas = Math.floor(totalMinutos / 60);
    const minutos = totalMinutos % 60;
    this.relatorio.duracao = `${horas}h ${minutos}min`;
    return this;
  }

  // Retorna o objeto Relatório completo.
  build() {
    return this.relatorio;
  }
}

export default RelatorioTarefaBuilder;

```

#### 6.2.2. Utilização no Serviço de Finalização
```
// src/services/TarefaService.js
import RelatorioTarefaBuilder from './RelatorioTarefaBuilder.js';

class TarefaService {
  // Calcula a diferença entre duas datas em minutos.
  _calcularDuracao(inicioISO, fimISO) {
    // Garante que temos dados válidos para calcular
    if (!inicioISO || !fimISO) {
      return -1; // Retorna um valor que o Builder saberá tratar
    }
    
    try {
      const inicio = new Date(inicioISO);
      const fim = new Date(fimISO);
      const diffMs = fim.getTime() - inicio.getTime(); // Diferença em milissegundos
      
      // Se a diferença for negativa, retorna 0
      if (diffMs < 0) {
        return 0;
      }

      // Converte milissegundos para minutos
      const diffMinutos = Math.round(diffMs / (1000 * 60));
      return diffMinutos;
    } catch (error) {
      console.error("Erro ao calcular duração:", error);
      return -1;
    }
  }

  // Finaliza uma tarefa e gera um relatório de conclusão.

  finalizarTarefa(tarefa) {
    // Lógica de negócio da US (atualizar o estado da tarefa)
    tarefa.finalizada = true;
    tarefa.dataFinalizacao = new Date().toISOString();

    // Lógica do Serviço: calcular os dados dinâmicos
    const duracaoEmMinutos = this._calcularDuracao(
      tarefa.dataInicio, 
      tarefa.dataFinalizacao
    );

    // Usar o Builder para construir o "Produto" (o Relatório)
    const relatorio = new RelatorioTarefaBuilder()
      .adicionarTitulo(tarefa.titulo)
      .adicionarDescricao(tarefa.descricao)
      .adicionarDataFinalizacao(tarefa.dataFinalizacao) // Passa o ISO
      .adicionarDuracao(duracaoEmMinutos) // Passa os minutos
      .build();

    console.log("Relatório gerado:", relatorio);

    // Retorna o produto final gerado
    return relatorio;
  }
}

export default TarefaService;

```

## 7. Como Executar a Implementação

### 7.1 Pré-requisitos
- Node.js instalado
- Projeto configurado com a estrutura de pastas src/services

### 7.2 Passos para Execução
1. Clone o repositório:
    ```bash
    git clone https://github.com/UnBArqDsw2025-2-Turma02/2025.2_T02_G1_OquePlanejoFazer_Entrega_03.git
    git checkout feat/finalizar_tarefa

    ```

2. Inicie o servidor:
    ```bash
    cd backend
    npm install
    npm start
    ```

3. Teste as rotas de criação: Substitua ":id" pelo ID da tarefa que deseja finalizar.
    ```
    PUT /api/tarefas/:id/finalizar 
    ```

## 8. Video da Execução do Código

    COLOCAR O VIDEO BEM AQUI !!

## 9. Conclusões da Implementação

A aplicação do padrão Builder na funcionalidade de finalização de tarefas trouxe maior organização e extensibilidade ao sistema.

O encapsulamento do processo de criação do relatório garantiu baixo acoplamento entre as classes, tornando o código mais legível e sustentável.

Além disso, a estrutura facilita futuras expansões, como geração de relatórios em PDF ou integração com APIs externas, sem alterar a lógica central da aplicação.

## Referências Bibliográficas

>SERRANO, Milene. Arquitetura e Desenho de Software - Aula GoFs Criacionais. Universidade de Brasília (UnB), Campus Gama. [Material de Aula].

>REFACTORING.GURU. Padrões de Projeto. Disponível em: https://refactoring.guru/pt-br/design-patterns. Acesso em: 22 de outubro de 2025.

> GAMMA, E. et al. Padrões de Projeto: Soluções Reutilizáveis de Software Orientado a Objetos. Porto Alegre: Bookman, 1995.

## Histórico de Versões
| Versão | Alteração | Responsável | Data | Revisor |  Detalhes da Revisão | Data da Revisão |
|--------|-----------|-------------|------|---------|----------------------|-----------------|
| 1.0 | Criação da página e inserção de: introdução, metodologia, senso crítico, justificativa e código.  | [Camila Careli](https://github.com/camilascareli) | 23/10/2025 | [SEUGIT](https://github.com/SEUGITAQUI) | - | XX/XX/2025 |