# 3.3.1 Command

## 3.3.1.1. Introdução

O padrão Command é um padrão de projeto comportamental que transforma uma solicitação ou ação em um objeto independente, contendo todas as informações necessárias para executá-la, desfazê-la ou armazená-la para uso posterior. Sua principal função é desacoplar o objeto que emite uma solicitação daquele que a executa, permitindo que comandos sejam facilmente parametrizados, enfileirados, registrados ou desfeitos.

Ele é amplamente utilizado em situações onde é necessário:

- Executar operações de forma flexível e controlada, como em sistemas de tarefas, editores de texto, ou aplicações com botões de “desfazer/refazer”;
- Registrar histórico de ações, possibilitando reexecução ou rollback;
- Agendar ou enfileirar comandos, especialmente em sistemas distribuídos ou com processamento assíncrono;
- Padronizar ações, tornando-as intercambiáveis e reutilizáveis em diferentes contextos.

## 3.3.1.2. Metodologia

### 3.3.1.2.1 Estrutura do Padrão no Projeto

O padrão Command foi implementado no projeto com os seguintes componentes:

1. **Command**: Classe que implementam a lógica de edição de tarefas
2. **ConcreteCommand**: `EditarTarefaCommand`, `EditarTarefaSimplesCommand`, `ConverterParaTarefaComPrazoCommand`, `ConverterParaTarefaRecorrenteCommand`
3. **Receiver**: `TarefaService` que executa as operações de persistência
4. **Invoker**: `TarefaCommandInvoker` que executa os comandos
5. **Client**: `TarefaController` que cria e executa comandos
6. **Factory**: `TarefaCommandFactory` que cria comandos apropriados

### 3.3.1.2.2 Arquitetura do Sistema

O padrão Command foi integrado ao sistema de gerenciamento de tarefas, permitindo:
- Edição inteligente de tarefas com conversão automática de tipos
- Validações específicas por tipo de tarefa
- Separação clara entre lógica de negócio e interface

## 3.3.1.3. Modelagem

O diagrama abaixo ilustra a aplicação do Command no contexto de edição de tarefas. Nele, o Usuário (Client) interage com o Invoker, que é responsável por acionar o comando apropriado sem conhecer sua implementação interna. O ComandoEditarTarefa, representando o ConcreteCommand, encapsula os dados e a lógica necessários para realizar ou desfazer a operação, delegando a execução ao ServicoTarefa (Receiver), que contém os métodos que realmente executam as ações de negócio, como editar ou converter uma tarefa. Essa estrutura garante baixo acoplamento, extensibilidade e organização clara das responsabilidades, permitindo que novas operações de edição ou conversão sejam adicionadas sem alterar o fluxo principal, que seria a interação entre o usuário e o sistema para editar uma tarefa.

<center> <img width="588" height="519" alt="Image" src="https://github.com/user-attachments/assets/f09f9eb9-4508-4691-9ea9-54f3169f09c0" /> </center>
<center> Autores: Millena e Yasmim </center>

## 3.3.1.4. Código

### 3.3.1.4.1 Estrutura de Implementação

A implementação foi organizada na seguinte estrutura de arquivos e diretórios:

```
backend/src/
├── models/
│   ├── commands/
│   │   ├── TarefaCommand.js (classe base)
│   │   ├── EditarTarefaCommand.js (comando para edição de tarefas)
│   │   ├── ConverterParaTarefaComPrazoCommand.js (comando para conversão para tarefa com prazo)
│   │   └── ConverterParaTarefaRecorrenteCommand.js (comando para conversão para tarefa recorrente)
│   │   └── TarefaCommandInvoker.js (Invoker que executa os comandos)
│   └── services/
│       └── TarefaService.js (Receiver que executa as operações de negócio)
├── controllers/
│   ├── TarefaController.js (Client que utiliza os comandos)
```

#### 3.3.1.4.1.1 Classe Base e Comandos Concretos

Define a classe base TarefaCommand, que serve como interface para os comandos concretos. Inclui o método abstrato execute, que deve ser implementado pelas subclasses.

Arquivo: `backend/src/models/commands/TarefaCommand.js`

```javascript
export class EditarTarefaCommand {
  constructor(tarefaId, dadosAtualizacao, tarefaService) {
    this.tarefaId = tarefaId;
    this.dadosAtualizacao = dadosAtualizacao;
    this.tarefaService = tarefaService;
  }

  async execute() {
    if (this.dadosAtualizacao.titulo && this.dadosAtualizacao.titulo.trim() === '') {
      throw new Error('Título não pode estar vazio');
    }
    
    if (this.dadosAtualizacao.estimativa && this.dadosAtualizacao.estimativa <= 0) {
      throw new Error('Estimativa deve ser maior que zero');
    }

    const tarefaAtual = await this.tarefaService.buscarTarefaPorId(this.tarefaId);
    
    const novoTipo = this.determinarNovoTipo(tarefaAtual.tipo, this.dadosAtualizacao);
    
    if (novoTipo !== tarefaAtual.tipo) {
      return await this.converterTipoTarefa(tarefaAtual, novoTipo, this.dadosAtualizacao);
    } else {
      return await this.tarefaService.editarTarefa(this.tarefaId, this.dadosAtualizacao);
    }
  }

  determinarNovoTipo(tipoAtual, dadosAtualizacao) {
    if (dadosAtualizacao.repeticao) {
      return 'recorrente';
    }
    
    if (dadosAtualizacao.dataVencimento && !dadosAtualizacao.repeticao) {
      return 'comPrazo';
    }
    
    if (tipoAtual !== 'simples' && 
        dadosAtualizacao.dataVencimento === null && 
        dadosAtualizacao.repeticao === null) {
      return 'simples';
    }
    
    return tipoAtual;
  }

  async converterTipoTarefa(tarefaAtual, novoTipo, dadosAtualizacao) {
    const novaTarefa = await this.tarefaService.converterTipoTarefa(
      tarefaAtual, 
      novoTipo, 
      dadosAtualizacao
    );
    
    return novaTarefa;
  }
}

export class EditarTarefaSimplesCommand extends EditarTarefaCommand {
  async execute() {
    if (this.dadosAtualizacao.titulo && this.dadosAtualizacao.titulo.trim() === '') {
      throw new Error('Título não pode estar vazio');
    }
    
    if (this.dadosAtualizacao.estimativa && this.dadosAtualizacao.estimativa <= 0) {
      throw new Error('Estimativa deve ser maior que zero');
    }

    return await this.tarefaService.editarTarefa(this.tarefaId, this.dadosAtualizacao);
  }
}

export class ConverterParaTarefaComPrazoCommand extends EditarTarefaCommand {
  async execute() {
    if (!this.dadosAtualizacao.dataVencimento) {
      throw new Error('Data de vencimento é obrigatória para conversão');
    }

    const tarefaAtual = await this.tarefaService.buscarTarefaPorId(this.tarefaId);
    
    return await this.tarefaService.converterTipoTarefa(
      tarefaAtual, 
      'comPrazo', 
      this.dadosAtualizacao
    );
  }
}

export class ConverterParaTarefaRecorrenteCommand extends EditarTarefaCommand {
  async execute() {
    if (!this.dadosAtualizacao.repeticao) {
      throw new Error('Repetição é obrigatória para conversão');
    }

    const tarefaAtual = await this.tarefaService.buscarTarefaPorId(this.tarefaId);
    
    return await this.tarefaService.converterTipoTarefa(
      tarefaAtual, 
      'recorrente', 
      this.dadosAtualizacao
    );
  }
}

```

#### 3.3.1.4.1.2 Serviço de Tarefas (Receiver)

Centraliza a lógica de negócio relacionada às tarefas, como edição, conversão de tipos e persistência. Atua como o Receiver no padrão Command.

Arquivo: `backend/src/models/services/TarefaService.js`

```javascript
export class TarefaService {
  constructor(persistencia = null) {
    this.fabricaTarefas = new GerenciadorFabricaTarefas();
    this.persistencia = persistencia || new PersistenciaMongoDB(Tarefa, this.fabricaTarefas);
  }

  async buscarTarefaPorId(tarefaId) {
    return await this.persistencia.buscarPorId(tarefaId);
  }

  async editarTarefa(tarefaId, dadosAtualizacao) {
    return await this.persistencia.atualizar(tarefaId, dadosAtualizacao);
  }

  async converterTipoTarefa(tarefaAtual, novoTipo, dadosAtualizacao) {
    return await this.persistencia.converterTipo(tarefaAtual, novoTipo, dadosAtualizacao);
  }

  async listarTarefas() {
    return await this.persistencia.buscarTodos();
  }

  async removerTarefa(tarefaId) {
    return await this.persistencia.deletar(tarefaId);
  }

  async salvarTarefa(tarefa) {
    return await this.persistencia.salvar(tarefa);
  }
}
```

#### 3.3.1.4.1.3 Invoker

Gerencia os comandos, permitindo que sejam enfileirados e executados em sequência. Atua como o Invoker no padrão Command.

Arquivo: `backend/src/controllers/TarefaCommandInvoker.js`

```javascript
class TarefaCommandInvoker {
  constructor() {
    this.comandos = [];
  }

  adicionarComando(comando) {
    this.comandos.push(comando);
  }

  executarComandos() {
    this.comandos.forEach((comando) => comando.execute());
    this.comandos = [];
  }
}

module.exports = TarefaCommandInvoker;
```

#### 3.3.1.4.1.4 Controlador (Client)

Atua como o Client no padrão Command, criando os comandos apropriados com base nas solicitações do usuário e delegando sua execução ao Invoker.

Arquivo: `backend/src/controllers/TarefaController.js`

```javascript
const {
  EditarTarefaCommand,
  ConverterParaTarefaComPrazoCommand,
  ConverterParaTarefaRecorrenteCommand,
} = require("../models/commands/TarefaCommand");
const TarefaService = require("../models/services/TarefaService");
const TarefaCommandInvoker = require("./TarefaCommandInvoker");

class TarefaController {
  static atualizarTarefa(req, res) {
    const tarefaService = new TarefaService();
    const invoker = new TarefaCommandInvoker();

    const { tipo, dados } = req.body;

    let comando;
    switch (tipo) {
      case "editar":
        comando = new EditarTarefaCommand(tarefaService, dados);
        break;
      case "prazo":
        comando = new ConverterParaTarefaComPrazoCommand(tarefaService, dados);
        break;
      case "recorrente":
        comando = new ConverterParaTarefaRecorrenteCommand(tarefaService, dados);
        break;
      default:
        return res.status(400).send("Tipo de comando inválido.");
    }

    invoker.adicionarComando(comando);
    invoker.executarComandos();

    res.status(200).send("Comando executado com sucesso.");
  }
}

module.exports = TarefaController;
```

### 3.3.1.4.2 Exemplos de Uso

#### 3.3.1.4.2.1 Edição Simples de Tarefa

```bash
# Criar uma tarefa simples
curl -X POST http://localhost:3333/api/tarefas/simples \
  -H "Content-Type: application/json" \
  -d '{"titulo": "Tarefa de Teste", "descricao": "Descrição da tarefa", "prioridade": "Média", "estimativa": 60}'

# Editar apenas o título (usa EditarTarefaCommand)
curl -X PUT http://localhost:3333/api/tarefas/IDdatarefa \
  -H "Content-Type: application/json" \
  -d '{"titulo": "Tarefa Editada", "prioridade": "Alta"}'
```

#### 3.3.1.4.2.2 Conversão Automática de Tipo

```bash
# Converter tarefa simples para tarefa com prazo
curl -X PUT http://localhost:3333/api/tarefas/IDdatarefa \
  -H "Content-Type: application/json" \
  -d '{"dataVencimento": "2024-12-31T23:59:59.000Z"}'

# Converter tarefa para recorrente
curl -X PUT http://localhost:3333/api/tarefas/IDdatarefa \
  -H "Content-Type: application/json" \
  -d '{"repeticao": "diária", "dataVencimento": "2024-12-31T23:59:59.000Z"}'
```

## 3.3.1.5. Conclusão

Em conclusão, o uso do padrão Command trouxe uma estrutura mais flexível ao processo de edição de tarefas, permitindo desacoplar a execução das ações da lógica de controle e facilitando futuras extensões, como suporte a comandos de desfazer/refazer ou histórico de alterações. Apesar de, em um primeiro momento, parecer uma solução robusta demais para um escopo tão reduzido, sua implementação se mostrou estratégica, já que ao escalar o sistema, será uma escolha acertada por facilitar a ampliação das funcionalidades sem complicar o código.

## 3.3.1.6. Referências
>SERRANO, Milene. Arquitetura e Desenho de Software - Aula GoFs Comportamentais. Universidade de Brasília (UnB), Campus Gama. [Material de Aula].

>REFACTORING.GURU. Command. Disponível em: https://refactoring.guru/pt-br/design-patterns/command. Acesso em: 22 de outubro de 2025.

## 3.3.1.7. Histórico de Versões

| Versão | Alteração | Responsável | Data | Revisor |  Detalhes da Revisão | Data da Revisão |
|--------|-----------|-------------|------|---------|----------------------|-----------------|
| 1.0 | Introdução, metodologia e aplicação do command |  [Millena](https://github.com/MillenaQueiroz) | 22/10/2025 | [NOME](https://github.com/SEUGITHUB) | ---  | XX/XX/XX |