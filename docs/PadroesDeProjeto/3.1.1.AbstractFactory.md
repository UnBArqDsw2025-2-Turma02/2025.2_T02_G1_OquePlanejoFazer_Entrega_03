# 3.1.1 Abstract Factory
## Introdução

No desenvolvimento orientado a objetos, um dos desafios mais comuns é criar objetos sem deixar o código dependente de classes específicas. Usar o comando new diretamente pode prejudicar a manutenibilidade, pois faz com que o código cliente fique acoplado a implementações concretas. Para resolver esse problema, surgiram os padrões de projeto criacionais, que propõem diferentes formas de criar objetos. Um dos mais conhecidos é o Factory Method.

Segundo a definição da Gang of Four (Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides), a intenção do padrão é: “Fornecer uma interface para criar famílias de objetos relacionados ou dependentes sem especificar suas classes concretas.” 

O Factory Method tem como objetivo delegar a responsabilidade de criar objetos para subclasses. Assim, em vez de instanciar diretamente um objeto, como um InimigoChefe, o código pede para uma “fábrica de inimigos” fazer isso. Essa abordagem torna o sistema mais flexível e fácil de manter, já que o código cliente não precisa saber qual classe específica está sendo criada.

Na prática, isso significa que o código cliente não precisa conhecer os detalhes de como os objetos são criados, apenas com quais interfaces deve interagir. 

A estrutura básica do Abstract Factory funciona da seguinte forma, supondo que temos vários tipos de animais:

- Interface da Fábrica Abstrata (AbstractFactory): define um conjunto de métodos para criar cada tipo de animal da família, como criarAnimalTerrestre() e criarAnimalAquatico().

- Fábricas Concretas (ConcreteFactory): são as implementações específicas da fábrica abstrata. Por exemplo, FabricaAnimaisSelvagens e FabricaAnimaisDomesticos, cada uma responsável por criar animais do seu próprio tipo de ambiente.

- Interfaces dos Produtos Abstratos (AbstractProduct): são as interfaces que definem o comportamento comum dos animais, como AnimalTerrestre e AnimalAquatico. Elas estabelecem o que todos os animais daquele tipo devem ser capazes de fazer (por exemplo, emitir som, mover-se ou se alimentar).

- Produtos Concretos (ConcreteProduct): são as implementações específicas dos animais, como Leao e Cachorro (animais terrestres) ou PeixePalhaco e Tubarão (animais aquáticos). Cada classe representa uma variação concreta dentro da sua respectiva família.

## Modelagem

<center><small>Figura 1: Diagrama</small></center>

![modelagem-abstract-factory](https://github.com/user-attachments/assets/193a0601-57d7-4e31-be1d-3f7bcb6c29e5)

<center><small>Fonte: Yasmim Rosa e Millena Queiroz</small></center>

No diagrama, temos as diretrizes para as fábricas e produtos:
- Interface da Fábrica Abstrata (AbstractFactory): define o contrato para a criação de tarefas, como o método criarTarefa(). Essa interface é representada pela classe FábricaTarefas, que estabelece o padrão que todas as fábricas concretas devem seguir para gerar diferentes tipos de tarefas.

- Fábricas Concretas (ConcreteFactory): são as implementações específicas da fábrica abstrata. No diagrama, temos FábricaTarefasPontuais e FábricaTarefasTemporais. Cada uma é responsável por criar uma família de tarefas relacionadas: a primeira cria tarefas pontuais, como TarefaSimples, enquanto a segunda cria tarefas temporais, como TarefaComPrazo e TarefaRecorrente.

- Interface dos Produtos Abstratos (AbstractProduct): é representada pela classe Tarefas, que define a estrutura e o comportamento base de todas as tarefas do sistema, como os métodos editar(), remover() e concluir(). Todas as tarefas concretas herdam dessa interface, garantindo um comportamento comum e permitindo que o código cliente trabalhe de forma genérica com qualquer tipo de tarefa.

- Produtos Concretos (ConcreteProduct): são as classes específicas que implementam o comportamento das tarefas. No diagrama, temos TarefaSimples, TarefaComPrazo e TarefaRecorrente. Cada uma possui características próprias, por exemplo, TarefaComPrazo tem o atributo dataVencimento, e TarefaRecorrente possui repeticao. Essas classes representam as variações concretas dentro de suas respectivas famílias de tarefas.

## Informações Técnicas e Implementação
### Tecnologias Utilizadas
- NodeJS (v22.20.0)
- ExpressJS (v4.18.2)
- MongoDB Atlas (hospedado)

### Estrutura de Implementação

A implementação foi organizada na seguinte estrutura de arquivos e diretórios:

```
backend/src/
├── models/
│   └── Tarefa.js (contém todas as classes do Abstract Factory)
└── controllers/
    └── TarefaController.js (cliente que utiliza as fábricas)
```

### Interface dos Produtos Abstratos (AbstractProduct)

Estas interfaces definem o contrato para os produtos que as fábricas criarão através dos schemas do Mongoose.

**Arquivo:** [`backend/src/models/Tarefa.js`](../backend/src/models/Tarefa.js) (linhas 7-69)

```javascript
// Schema base da tarefa (InterfaceProduto)
const tarefaSchema = new mongoose.Schema({
  id: { 
    type: String, 
    default: gerarIdAleatorio,
    unique: true 
  },
  titulo: { 
    type: String, 
    required: true 
  },
  descricao: { 
    type: String, 
    required: true 
  },
  prioridade: { 
    type: String, 
    enum: ['Baixa', 'Média', 'Alta'], 
    default: 'Média' 
  },
  estimativa: { 
    type: Number, 
    required: true 
  },
  criadoEm: { 
    type: Date, 
    default: Date.now 
  },
  atualizadoEm: { 
    type: Date, 
    default: Date.now 
  },
  concluida: { 
    type: Boolean, 
    default: false 
  },
  tipo: {
    type: String,
    enum: ['simples', 'comPrazo', 'recorrente'],
    required: true
  }
}, {
  timestamps: true
});

// Métodos da interface (InterfaceProduto)
tarefaSchema.methods.editar = function({ titulo, descricao, prioridade, estimativa, dataVencimento, repeticao }) {
  if (titulo) this.titulo = titulo;
  if (descricao) this.descricao = descricao;
  if (prioridade) this.prioridade = prioridade;
  if (estimativa) this.estimativa = estimativa;
  if (dataVencimento !== undefined) this.dataVencimento = dataVencimento;
  if (repeticao !== undefined) this.repeticao = repeticao;
  this.atualizadoEm = new Date();
};

tarefaSchema.methods.concluir = function() {
  this.concluida = true;
  this.atualizadoEm = new Date();
  return `Tarefa "${this.titulo}" concluída!`;
};

tarefaSchema.methods.remover = function() {
  return `Tarefa "${this.titulo}" removida`;
};
```

O schema base da tarefa desacopla o cliente das implementações concretas. O cliente interage com os objetos apenas através desses métodos comuns, sem conhecer as classes específicas TarefaSimples, TarefaComPrazo ou TarefaRecorrente.

### Interface da Fábrica Abstrata (AbstractFactory)

Esta classe é o contrato que todas as fábricas concretas devem seguir.

**Arquivo:** [`backend/src/models/Tarefa.js`](../backend/src/models/Tarefa.js) (linhas 106-110)

```javascript
// Interface da Fábrica Abstrata (AbstractFactory)
class FabricaTarefas {
  criarTarefa() {
    throw new Error('Método criarTarefa deve ser implementado pela subclasse');
  }
}
```

FabricaTarefas declara os métodos de criação para cada tipo de tarefa da família. O cliente usará esta interface para solicitar a criação de objetos, sem saber qual fábrica concreta está em uso.

### Implementações Concretas (ConcreteProduct e ConcreteFactory)

Classes que implementam as interfaces para as famílias "Pontuais" e "Temporais".

**Arquivo:** [`backend/src/models/Tarefa.js`](../backend/src/models/Tarefa.js) (linhas 71-147)

```javascript
// Produtos Concretos (ConcreteProduct)
const tarefaSimplesSchema = new mongoose.Schema({
}, {
  discriminatorKey: 'tipo'
});

const tarefaComPrazoSchema = new mongoose.Schema({
  dataVencimento: { 
    type: Date, 
    required: true 
  }
}, {
  discriminatorKey: 'tipo'
});

const tarefaRecorrenteSchema = new mongoose.Schema({
  repeticao: { 
    type: String, 
    required: true,
    enum: ['diária', 'semanal', 'mensal', 'anual']
  },
  dataVencimento: { 
    type: Date, 
    default: null 
  }
}, {
  discriminatorKey: 'tipo'
});

const Tarefa = mongoose.model('Tarefa', tarefaSchema);
const TarefaSimples = Tarefa.discriminator('simples', tarefaSimplesSchema);
const TarefaComPrazo = Tarefa.discriminator('comPrazo', tarefaComPrazoSchema);
const TarefaRecorrente = Tarefa.discriminator('recorrente', tarefaRecorrenteSchema);

// Fábricas Concretas (ConcreteFactory)
class FabricaTarefasPontuais extends FabricaTarefas {
  criarTarefa(titulo, descricao, prioridade, estimativa) {
    return new TarefaSimples({
      titulo,
      descricao,
      prioridade,
      estimativa,
      tipo: 'simples'
    });
  }
}

class FabricaTarefasTemporais extends FabricaTarefas {
  criarTarefaComPrazo(titulo, descricao, prioridade, estimativa, dataVencimento) {
    return new TarefaComPrazo({
      titulo,
      descricao,
      prioridade,
      estimativa,
      dataVencimento,
      tipo: 'comPrazo'
    });
  }

  criarTarefaRecorrente(titulo, descricao, prioridade, estimativa, repeticao, dataVencimento = null) {
    return new TarefaRecorrente({
      titulo,
      descricao,
      prioridade,
      estimativa,
      repeticao,
      dataVencimento,
      tipo: 'recorrente'
    });
  }
}
```

 Cada fábrica concreta é especializada em criar uma família de tarefas relacionadas: FabricaTarefasPontuais produz TarefaSimples, enquanto FabricaTarefasTemporais produz TarefaComPrazo e TarefaRecorrente. Essa especialização assegura que os produtos gerados por uma mesma fábrica sejam sempre compatíveis entre si.

### Camada de Serviço (Client)

A classe GerenciadorFabricaTarefas atua como o cliente do padrão, orquestrando as fábricas.

**Arquivo:** [`backend/src/models/Tarefa.js`](../backend/src/models/Tarefa.js) (linhas 149-166)

```javascript
// Cliente do Abstract Factory
class GerenciadorFabricaTarefas {
  constructor() {
    this.fabricaPontual = new FabricaTarefasPontuais();
    this.fabricaTemporal = new FabricaTarefasTemporais();
  }

  criarTarefaSimples(titulo, descricao, prioridade, estimativa) {
    return this.fabricaPontual.criarTarefa(titulo, descricao, prioridade, estimativa);
  }

  criarTarefaComPrazo(titulo, descricao, prioridade, estimativa, dataVencimento) {
    return this.fabricaTemporal.criarTarefaComPrazo(titulo, descricao, prioridade, estimativa, dataVencimento);
  }

  criarTarefaRecorrente(titulo, descricao, prioridade, estimativa, repeticao, dataVencimento) {
    return this.fabricaTemporal.criarTarefaRecorrente(titulo, descricao, prioridade, estimativa, repeticao, dataVencimento);
  }
}
```

O GerenciadorFabricaTarefas recebe solicitações, determina qual fábrica concreta utilizar com base no tipo de tarefa solicitado, e orquestra a criação da família de produtos. O cliente está completamente desacoplado das classes concretas das tarefas.

### Uso no Controller

O TarefaController utiliza o Abstract Factory para criar tarefas:

**Arquivo:** [`backend/src/controllers/TarefaController.js`](../backend/src/controllers/TarefaController.js) (linhas 14-35)

```javascript
// Uso do Abstract Factory no Controller
class TarefaController {
  constructor() {
    this.fabricaTarefas = new GerenciadorFabricaTarefas();
    this.tarefaService = new TarefaService();
  }

  async criarTarefaSimples(req, res) {
    try {
      const { titulo, descricao, prioridade, estimativa } = req.body;
      
      if (!titulo || !descricao || !estimativa) {
        return res.status(400).json({ 
          error: 'Titulo, descrição e estimativa são obrigatórios' 
        });
      }

      const tarefa = this.fabricaTarefas.criarTarefaSimples(titulo, descricao, prioridade, estimativa);
      await tarefa.save();
      
      res.status(201).json({
        message: 'Tarefa simples criada com sucesso',
        tarefa
      });
    } catch (error) {
      console.error('Erro ao criar tarefa simples:', error);
      res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }
}
```
O controller utiliza a fábrica para criar tarefas específicas sem conhecer os detalhes de implementação de cada tipo. Isso torna o código mais flexível e fácil de manter.


## Participação
A implementação e diagramação foi realizada em dupla por [Millena Queiroz](https://github.com/MillenaQueiroz) e [Yasmim Rosa](https://github.com/yaskisoba). 


## Referências
>SERRANO, Milene. Arquitetura e Desenho de Software - Aula GoFs Criacionais. Universidade de Brasília (UnB), Campus Gama. [Material de Aula].

> Padrão de Projeto Abstract Factory. In: REFACTORING.GURU. [s. d.]. Disponível em: https://refactoring.guru/pt-br/design-patterns/abstract-factory
. Acesso em: 22 out. 2025.

> Abstract factory. In: WIKIPÉDIA, a enciclopédia livre. Flórida: Wikimedia Foundation, 2023. Disponível em: https://pt.wikipedia.org/wiki/Abstract_factory
. Acesso em: 22 out. 2025.

>MIRANDA, Nelson. Desvendando os Padrões de Projeto: Abstract Factory e Factory Method. Medium, 2023. Disponível em: https://medium.com/@nelson.miranda_40644/desvendando-os-padr%C3%B5es-de-projeto-abstract-factory-e-factory-method-7fc12854cd2a
. Acesso em: 22 out. 2025.




## Histórico de Versões
| Versão | Alteração | Responsável | Data | Revisor |  Detalhes da Revisão | Data da Revisão |
|--------|-----------|-------------|------|---------|----------------------|-----------------|
| 1.0 | Implementação do Abstract Factory | [Yasmim Rosa](https://github.com/yaskisoba) | 22/10/2025 | - | -  | - |
